<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tzf-web</title>
    <meta name="author" content="ringsaturn" />
    <meta name="keywords" content="tzf, timezone, wasm, leaflet, protomaps" />
    <meta
      name="description"
      content="A simple web app to find the timezone of a location using WebAssembly."
    />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:creator" content="@ringsaturn_me" />

    <meta name="og:image" content="./android-chrome-512x512.png" />
    <meta property="og:url" content="https://ringsaturn.github.io/tzf-web/" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="tzf-web" />
    <meta
      property="og:description"
      content="A simple web app to find the timezone of a location using WebAssembly."
    />
    <meta property="og:site_name" content="tzf-web" />

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="./apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="./favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="./favicon-16x16.png"
    />
    <link rel="manifest" href="./site.webmanifest" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script
      src="https://unpkg.com/protomaps-leaflet/dist/protomaps-leaflet.js"
    ></script>

    <script type="module">
      import init, {
        WasmFinder,
      } from "https://unpkg.com/tzf-wasm@0.1.5/tzf_wasm.js";

      // 定义一组视觉上区分度高的颜色
      const colorPalette = [
        "#2c5282", // 深蓝色
        "#c53030", // 深红色
        "#2f855a", // 深绿色
        "#744210", // 深棕色
        "#553c9a", // 深紫色
        "#702459", // 深粉色
        "#1a365d", // 海军蓝
        "#975a16", // 赭石色
        "#285e61", // 深青色
        "#822727", // 暗红色
        "#45359a", // 靛蓝色
        "#5b3f11", // 深褐色
        "#234e52", // 深绿青
        "#48366d", // 深靛蓝
        "#3c366b", // 深紫蓝
      ];

      window.finder = null;
      window.loadedTimezones = new Set(); // 记录已加载的时区
      window.timezoneColors = new Map(); // 存储时区和颜色的映射
      window.indexLayers = new Map(); // 存储索引图层
      let colorIndex = 0;

      // 从 localStorage 读取显示索引数据的配置
      window.showIndexData =
        localStorage.getItem("showIndexData") === "true";

      // Initialize map and base layers first
      var southWest = L.latLng(-90, -180);
      var northEast = L.latLng(90, 180);
      var bounds = L.latLngBounds(southWest, northEast);
      var map = L.map("map", {
        maxBounds: bounds,
        maxBoundsViscosity: 1,
        worldCopyJump: true,
        maxZoom: 18,
        minZoom: 3,
        cursor: true,
      });

      // Set a temporary default view
      map.setView([40.7128, -74.0060], 2);

      var layer = protomapsL.leafletLayer({
        url:
          "https://api.protomaps.com/tiles/v3/{z}/{x}/{y}.mvt?key=ee3e89f1234d79e1",
        theme: "white",
      });
      layer.addTo(map);

      // Add base map layers and controls
      map.attributionControl.addAttribution(
        '&copy; <a href="https://github.com/evansiroky/timezone-boundary-builder" target="_blank">timezone-boundary-builder</a>',
      );

      L.GridLayer.GridDebug = L.GridLayer.extend({
        createTile: function (coords) {
          const tile = document.createElement("div");
          tile.style.outline = "1px solid rgba(208, 240, 192, 1)";
          tile.style.fontSize = "13pt";
          tile.style.opacity = "1";
          tile.innerHTML = [coords.z, coords.x, coords.y].join("/");
          return tile;
        },
      });
      L.gridLayer.gridDebug = function (opts) {
        return new L.GridLayer.GridDebug(opts);
      };

      map.addLayer(L.gridLayer.gridDebug());

      // Helper functions
      function getTimezoneColor(timezone) {
        if (!window.timezoneColors.has(timezone)) {
          window.timezoneColors.set(
            timezone,
            colorPalette[colorIndex % colorPalette.length],
          );
          colorIndex++;
        }
        return window.timezoneColors.get(timezone);
      }

      window.toggleIndexData = function () {
        window.showIndexData = !window.showIndexData;
        localStorage.setItem("showIndexData", window.showIndexData);

        document.getElementById("show-index-data").checked =
          window.showIndexData;

        for (const [timezone, layer] of window.indexLayers.entries()) {
          if (window.showIndexData) {
            layer.addTo(map);
          } else {
            layer.remove();
          }
        }
      };

      // Initialize UI state
      document.getElementById("show-index-data").checked =
        window.showIndexData;

      // Start initialization
      loadWasm();

      // Update URL when map view changes
      function updateURLState() {
        const center = map.getCenter();
        const zoom = map.getZoom();
        const hash = `#${zoom},${center.lng.toFixed(4)},${
          center.lat.toFixed(4)
        }`;

        const params = new URLSearchParams(window.location.search);

        if (window.loadedTimezones.size > 0) {
          params.set(
            "tzs",
            Array.from(window.loadedTimezones).join(","),
          );
        }

        const newURL = `${window.location.pathname}${
          params.toString() ? "?" + params.toString() : ""
        }${hash}`;
        window.history.replaceState(null, "", newURL);
      }

      // Add event listeners for URL state updates
      map.on("moveend", updateURLState);

      // Initialize WASM and process URL parameters
      async function loadWasm() {
        await init();
        finder = new WasmFinder();
        window.finder = finder;
        await parseURLParams();
      }

      // Event listeners
      document.getElementById("add-marker").addEventListener(
        "click",
        () => {
          const lat = parseFloat(
            document.getElementById("latitude").value,
          );
          const lon = parseFloat(
            document.getElementById("longitude").value,
          );
          if (!isNaN(lat) && !isNaN(lon)) {
            showTimezone(lat, lon, map);
          } else {
            alert("Please enter valid latitude and longitude values.");
          }
        },
      );

      map.on("mousemove", function (e) {
        var lng = e.latlng.wrap().lng.toFixed(4);
        var lat = e.latlng.wrap().lat.toFixed(4);
        if (finder) {
          var timezones = finder.get_tz_names(lng, lat);
          var joinedTimezones = timezones.join(", ");
          var dataVersion = finder.data_version();
          document.getElementById("mousecoord").innerHTML =
            `Data Version: ${dataVersion}<br>Lat: ${lat} Lng: ${lng}<br>Timezone: ${joinedTimezones}`;
        } else {
          document.getElementById("mousecoord").innerHTML =
            `Lat: ${lat} Lng: ${lng}`;
        }
      });

      map.on("click", function (e) {
        const lat = e.latlng.lat;
        const lng = e.latlng.lng;
        showTimezone(lat, lng, map);
      });

      window.showTimezone = async function (lat, lng, map) {
        if (finder) {
          if (isNaN(lng) || isNaN(lat)) {
            alert(
              "Please enter valid numbers for longitude and latitude.",
            );
            return;
          }

          if (lng < -180 || lng > 180) {
            alert(
              "Please enter a valid longitude between -180 and 180 degrees.",
            );
            return;
          }

          if (lat < -90 || lat > 90) {
            alert(
              "Please enter a valid latitude between -90 and 90 degrees.",
            );
            return;
          }

          const roundedLat = lat.toFixed(4);
          const roundedLng = lng.toFixed(4);
          const timezones = finder.get_tz_names(roundedLng, roundedLat);
          var joinedTimezones = timezones.join(", ");

          const marker = L.marker([roundedLat, roundedLng]).addTo(map);
          marker.bindPopup(
            `Latitude: ${roundedLat}<br>Longitude: ${roundedLng}<br>Timezone: ${joinedTimezones}`,
          ).openPopup();

          // Add point to URL
          const params = new URLSearchParams(window.location.search);
          params.append("load_points", `${roundedLng},${roundedLat}`);
          const hash = window.location.hash;
          const newURL =
            `${window.location.pathname}?${params.toString()}${hash}`;
          window.history.replaceState(null, "", newURL);

          for (const timezone of timezones) {
            if (!window.loadedTimezones.has(timezone)) {
              window.loadedTimezones.add(timezone);
              const geojsonPath = `./timezone-polygons/${
                timezone.replace(/\//g, "-")
              }.geojson`;
              const indexGeojsonPath = `./timezone-polygons-index/${
                timezone.replace(/\//g, "-")
              }.geojson`;

              try {
                // Load detailed boundaries
                const response = await fetch(geojsonPath);
                if (response.ok) {
                  const geojsonData = await response.json();
                  const timezoneColor = getTimezoneColor(timezone);
                  L.geoJSON(geojsonData, {
                    style: {
                      color: timezoneColor,
                      weight: 2.5,
                      opacity: 0.9,
                      fillColor: timezoneColor,
                      fillOpacity: 0.15,
                    },
                    onEachFeature: function (feature, layer) {
                      layer.bindTooltip(timezone.split("/").pop(), {
                        permanent: true,
                        direction: "center",
                        className: "timezone-label",
                      });
                    },
                  }).addTo(map);
                }

                // Load index boundaries
                const indexResponse = await fetch(indexGeojsonPath);
                if (indexResponse.ok) {
                  const indexGeojsonData = await indexResponse.json();
                  const timezoneColor = getTimezoneColor(timezone);
                  const indexTimezoneLayer = L.geoJSON(
                    indexGeojsonData,
                    {
                      style: {
                        color: timezoneColor,
                        weight: 1.5,
                        opacity: 0.7,
                        fillColor: timezoneColor,
                        fillOpacity: 0.1,
                      },
                    },
                  );

                  window.indexLayers.set(timezone, indexTimezoneLayer);
                  if (window.showIndexData) {
                    indexTimezoneLayer.addTo(map);
                  }
                }
              } catch (error) {
                console.error(
                  `Error loading GeoJSON for ${timezone}:`,
                  error,
                );
              }
            }
          }
          // Update URL after loading all timezones
          updateURLState();
        } else {
          alert(
            "WASM module is not loaded yet. Please Wait for seconds.",
          );
        }
      };

      async function parseURLParams() {
        const params = new URLSearchParams(window.location.search);
        const hash = window.location.hash.slice(1); // Remove the # symbol

        // Parse hash for map view state (#zoom,lng,lat)
        if (hash) {
          const [zoom, lng, lat] = hash.split(",").map(Number);
          if (!isNaN(zoom) && !isNaN(lng) && !isNaN(lat)) {
            map.setView([lat, lng], zoom);
          }
        }

        // Load timezones from URL
        const tzs = params.get("tzs");
        if (tzs) {
          const timezoneList = tzs.split(",");
          for (const timezone of timezoneList) {
            if (!window.loadedTimezones.has(timezone)) {
              window.loadedTimezones.add(timezone);
              const geojsonPath = `./timezone-polygons/${
                timezone.replace(/\//g, "-")
              }.geojson`;
              const indexGeojsonPath = `./timezone-polygons-index/${
                timezone.replace(/\//g, "-")
              }.geojson`;

              try {
                // Load detailed boundaries
                const response = await fetch(geojsonPath);
                if (response.ok) {
                  const geojsonData = await response.json();
                  const timezoneColor = getTimezoneColor(timezone);
                  L.geoJSON(geojsonData, {
                    style: {
                      color: timezoneColor,
                      weight: 2.5,
                      opacity: 0.9,
                      fillColor: timezoneColor,
                      fillOpacity: 0.15,
                    },
                    onEachFeature: function (feature, layer) {
                      layer.bindTooltip(timezone.split("/").pop(), {
                        permanent: true,
                        direction: "center",
                        className: "timezone-label",
                      });
                    },
                  }).addTo(map);
                }

                // Load index boundaries
                const indexResponse = await fetch(indexGeojsonPath);
                if (indexResponse.ok) {
                  const indexGeojsonData = await indexResponse.json();
                  const timezoneColor = getTimezoneColor(timezone);
                  const indexTimezoneLayer = L.geoJSON(
                    indexGeojsonData,
                    {
                      style: {
                        color: timezoneColor,
                        weight: 1.5,
                        opacity: 0.7,
                        fillColor: timezoneColor,
                        fillOpacity: 0.1,
                      },
                    },
                  );

                  window.indexLayers.set(timezone, indexTimezoneLayer);
                  if (window.showIndexData) {
                    indexTimezoneLayer.addTo(map);
                  }
                }
              } catch (error) {
                console.error(
                  `Error loading GeoJSON for ${timezone}:`,
                  error,
                );
              }
            }
          }
        }

        // Load points from URL
        const points = params.getAll("load_points");
        for (const point of points) {
          const [lng, lat] = point.split(",").map(Number);
          if (!isNaN(lng) && !isNaN(lat)) {
            showTimezone(lat, lng, map);
          }
        }
      }
    </script>

    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #coordinate-inputs {
        position: absolute;
        top: 10px;
        left: 10px;
        background: white;
        padding: 10px;
        border: 1px solid #ccc;
        z-index: 1000;
      }

      .controls-container {
        display: flex;
        align-items: center;
        margin-top: 10px;
      }

      .toggle-switch {
        margin-right: 8px;
      }

      .toggle-label {
        font-size: 14px;
        color: #4a5568;
      }

      .timezone-label {
        background: none;
        border: none;
        box-shadow: none;
        color: #1a202c;
        font-weight: bold;
        font-size: 11px;
        text-shadow:
          2px 2px 3px rgba(255, 255, 255, 0.9),
          -2px -2px 3px rgba(255, 255, 255, 0.9),
          2px -2px 3px rgba(255, 255, 255, 0.9),
          -2px 2px 3px rgba(255, 255, 255, 0.9);
      }
    </style>
  </head>

  <body>
    <div id="map"></div>
    <div id="coordinate-inputs">
      <label for="latitude">Lat:</label>
      <input type="text" id="latitude" name="latitude" />
      <br />
      <label for="longitude">Lng:</label>
      <input type="text" id="longitude" name="longitude" />
      <br />
      <button id="add-marker">Add Marker</button>
      <div class="controls-container">
        <input
          type="checkbox"
          id="show-index-data"
          class="toggle-switch"
          onchange="toggleIndexData()"
        />
        <label for="show-index-data" class="toggle-label"
        >Show Index Data</label>
      </div>
    </div>
    <span
      id="mousecoord"
      style="display: block; position: absolute; right: 0; top: 0; z-index: 9999; background-color: white"
    ></span>
  </body>
</html>
<footer
  style="position: absolute; bottom: 10px; left: 10px; background: white; padding: 10px; border: 1px solid #ccc; z-index: 1000"
>
  <ul>
    <li>
      <a href="https://ringsaturn.github.io/tzf-web/simple" target="_blank"
      >Simple Page</a>
    </li>
    <li>
      <a href="https://github.com/ringsaturn/tzf-web" target="_blank"
      >Project Repository</a>
    </li>
    <li>
      This project uses <a
        href="https://github.com/ringsaturn/tzf-wasm"
        target="_blank"
      >tzf-wasm</a>, which is a Wasm binding of <a
        href="https://github.com/ringsaturn/tzf-rs"
        target="_blank"
      >tzf-rs</a>.
    </li>
  </ul>
</footer>
